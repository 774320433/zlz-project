# 高性能Mysql

## 第一章 Mysql架构与历史

### 1.1 mysql逻辑架构

- Mysql连接管理与安全性: 一个连接就是一个线程，连接时认证用户名、原始主机信息、密码。连接成功后，继续验证客户端的权限信息。 

### 1.2 并发控制

- 什么是并发: 只要有多个查询需要在同一时刻修改数据，就会产生并发控制。那么，Mysql是如何控制并发的呢？使用锁(lock)控制。

- 读锁(共享锁): 读锁又称共享锁，相互不阻塞。多个客户在同一时间访问互不影响

- 写锁(排他锁): 写锁又称排他锁，写锁会阻塞其他的写锁和读锁。

- 锁颗粒度
    - 表级锁: 会锁定整张表，当用户执行(update、insert、delete)操作时。会影响其他的读写操作。此锁开销最小、并发程度最低
    - 行级锁: 会锁定某一行，不会影响其他数据的读写操作。此锁开销最大、并发程度最高
    
### 1.3 事务

- 什么是事务: 事务就是一组原子性的sql查询，或者说是一个工作单元。要么全部执行成功，要么全部执行失败。

- 事务应用场景:
 
```sql 
    # 银行转账，从用户Maco的账户转出200块到Jessica账户上
    # 1. 检查Maco的账户余额是否高于200元
    # 2. 从Maco账户上扣除200元
    # 3. 从Jessica的账户上增加200元

    start transaction
        select * from checking where balance >= 200
        update maco set balace - 200
        update jessica set balace + 200  
    commit; 
```

- 事务四大基本特征
    - 原子性(atomicity): 最小的工作单位,要么全部提交成功,要么全部回滚失败。
    - 一致性(consistency): 数据库总是从一个一致性的状态转移到另一个一致性的状态。例如:上述第三、第四条语句没有执行成功。Maco账户也不会损失200块
    - 隔离性(isolation): 一个事务所做修改在提交之前对其他事务是不可见的。 
    - 持久性(durability): 一旦事务提交，则其修改的数据将永久保存到数据库中。

- 隔离级别
    - 未提交读(READ UNCOMMITTED): 一个事务读取到另一个事务修改但未提交的数据(称为脏读). 此隔离级别会出现脏读、幻读、不可重复读。
    - 提交读(READ COMMITTED): 一个事务开启后，只能读取到另一个事务已经提交的数据。不会读取到修改未提交的数据(避免了脏读)，会出现幻读、不可重复读。
    - 可重复读(REPEATABLE READ): 一个事务开启后，这个事务所操作的数据不会被另一事务给修改。以此来保证事务内两个查询一致(解决了不可重复读)，不可重复读是Update导致的。但却无法避免幻读
    - 串行化(SERIALIZABLE): 事务串行顺序执行，给表上的每一条数据都加锁，可能导致大量的超时和锁争用的问题。这一隔离级别，脏读、幻读、不可重复读都不存在
